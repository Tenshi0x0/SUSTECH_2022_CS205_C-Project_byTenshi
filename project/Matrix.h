#include <opencv2/opencv.hpp>
#include <eigen3/Eigen/Dense>
#include <eigen3/Eigen/Eigen>
#ifndef MAT_H
#define MAT_H

#define x first
#define y second
#define debug(x) std::cerr << #x << ": " << (x) << std::endl

using std::vector;
using std::pair;
using std::complex;

// #include "eigen.h"

template<class T>
class Matrix{
private:
	int n, m; // number of row and column
	std::vector<std::vector<std::pair<int, T>>> R, C; // record the matrix by R and C

    vector<T> real_eigenvalues;
    vector<T> imag_eigenvalues;
	
public:
	Matrix(){}

	Matrix(int _n, int _m){
        assert(_n>0 && _m>0);
		n=_n, m=_m;
		R.resize(n);
		C.resize(m);
	}

    // resize the matrix (all data become 0)
    void resize(int _n, int _m){
        assert(_n>0 && _m>0);
        R.clear(), C.clear();
        n=_n, m=_m;
        R.resize(n);
        C.resize(m);
    }

    // all data to 0
    void O(){
        for(int i=0; i<n; i++) R[i].clear();
        for(int i=0; i<m; i++) C[i].clear();
    }

    // make this identity matrix
    void I(){
        assert(n==m);
        O();
        for(int i=0; i<n; i++) insert(i, i, 1);
    }
	
    // if the matrix generated by read, need to sort the R and C
	void sort(){
        auto cmp=[](std::pair<int, T> &a, std::pair<int, T> &b){
            assert(a.x!=b.x);
            return a.x<b.x;
        };
		for(int i=0; i<n; i++) std::sort(begin(R[i]), end(R[i]), cmp);
		for(int j=0; j<m; j++) std::sort(begin(C[j]), end(C[j]), cmp);
	}
	
    // insert tuple of element in the matrix
	void insert(int x, int y, T w){
		R[x].push_back({y, w});
		C[y].push_back({x, w});
	}

    // return the whole matrix 
    std::vector<std::vector<T>> getAll()const{
        std::vector<std::vector<T>> res;
        for(int i=0; i<n; i++){
            std::vector<T> col(m);
            for(auto &[x, y]: R[i]) col[x]=y;
            res.push_back(col);
        }
        return res;
    }

    // print matrix by std::cout
    void print(){
        auto mat=getAll();
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++) std::cout<<mat[i][j]<<(j==m-1? "\n": " ");
        }
    }

    // get result of Matrix A * Matrix B
	Matrix<T> operator * (const Matrix<T> &o)const{
		assert(m==o.n);
		Matrix<T> res(n, o.m);
		for(int i=0; i<n; i++){
			for(int j=0; j<o.m; j++){
				T val=0;
				for(int k=0, ko=0; k<R[i].size(); k++){
					while(ko<o.C[j].size() && o.C[j][ko].x<R[i][k].x) ko++;
					if(ko<o.C[j].size() && o.C[j][ko].x==R[i][k].x) val+=o.C[j][ko].y*R[i][k].y;
				}
				res.insert(i, j, val);
			}
		}
		res.sort();
		return res;
	}

     // get result of Matrix A * vector B
	vector<T> operator * (const vector<T> &o)const{
		assert(m==o.size());
		vector<T> res(o.size());
		for(int i=0; i<n; i++){
			vector<T> col(o.size());
            for(auto &[x, y]: R[i]) col[x]=y;
            for(int j=0; j<m; j++) res[i]+=col[j]*o[j];
		}
		return res;
	}

    // get result of Matrix A + Matrix B
	Matrix<T> operator + (const Matrix<T> &o)const{
		assert(m==o.m && n==o.n);
		Matrix<T> res(n, m);
		for(int i=0; i<n; i++){
            for(int k=0, ko=0; k<R[i].size() || ko<o.R[i].size(); ){
                if(R[i].size()==k || ko<o.R[i].size() && o.R[i][ko].x<R[i][k].x){
                	res.insert(i, o.R[i][ko].x, o.R[i][ko].y);
                	ko++;
                } 
                else if(o.R[i].size()==ko || k<R[i].size() && R[i][k].x<o.R[i][ko].x){
                	res.insert(i, R[i][k].x, R[i][k].y);
                	k++;
                }
                else{
                	res.insert(i, R[i][k].x, R[i][k].y+o.R[i][ko].y);
                	k++, ko++;
                }
            }
		}
		res.sort();
		return res;
	}

    // get result of Matrix A - Matrix B
    Matrix<T> operator - (const Matrix &o)const{
		assert(m==o.m && n==o.n);
		Matrix<T> res=o;
		for(int i=0; i<n; i++) for(auto &[x, y]: res.R[i]) y=-y;
		return *this+res;
	}

    Matrix<T> operator * (const T &k)const{
        Matrix<T> res=*this;
        for(int i=0; i<n; i++) for(auto &[x, y]: res.R[i]) y*=k;
        return res;
    }

    Matrix<T> operator / (const T &k)const{
        assert(k!=0);
        Matrix<T> res=*this;
        for(int i=0; i<n; i++) for(auto &[x, y]: res.R[i]) y/=k;
        return res;
    }

    // dot of two matrix
    Matrix<T> dot(Matrix &o){
		assert(m==o.m && n==o.n);
        Matrix<T> res(n, m);
        for(int i=0; i<n; i++){
            for(int k=0, ko=0; k<R[i].size() || ko<o.R[i].size(); ){
                if(R[i].size()==k || ko<o.R[i].size() && o.R[i][ko].x<R[i][k].x) ko++;
                else if(o.R[i].size()==ko || k<R[i].size() && R[i][k].x<o.R[i][ko].x) k++;
                else{
                	res.insert(i, R[i][k].x, R[i][k].y*o.R[i][ko].y);
                	k++, ko++;
                }
            }
        }
        return res;
    }

    Matrix<T> transposition(){
        std::swap(n, m);
        std::swap(R, C);
        Matrix<T> res=*this;
        std::swap(n, m);
        std::swap(R, C);
        return res;
    }

    template<class CT>
	Matrix<complex<CT>> conjugation(){
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) y.imag(-y.imag());
        for(int i=0; i<m; i++) for(auto &[x, y]: C[i]) y.imag(-y.imag());
        Matrix<complex<CT>> res=*this;
        res=res.transposition();
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) y.imag(-y.imag());
        for(int i=0; i<m; i++) for(auto &[x, y]: C[i]) y.imag(-y.imag());
        return res;
    }

    T get_max(){
        T res=0;
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) res=(res<y? y: res);
        return res;
    }

    T get_min(){
        T res=0;
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) res=(res>y? y: res);
        return res;
    }

    T get_sum(){
        T res=0;
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) res+=y;
        return res;
    }

    T get_trace(){
        assert(n==m);
        T res=0;
        for(int i=0; i<n; i++) for(auto &[x, y]: R[i]) if(x==i) res+=y;
        return res;
    }

    Matrix<T> get_inv(){
        const double eps=1e-10;
        assert(n==m);

        auto a=getAll();
        auto b=a;
        for(int i=0; i<n; i++) for(int j=0; j<n; j++) b[i][j]=(i==j);

        for(int i=0, r; i<n; i++){
            r=i;
            for(int j=i+1; j<n; j++)
                if(a[j][i]>a[r][i]) r=j;
            if(r!=i) std::swap(a[i], a[r]);
            assert(abs(a[i][i])>eps);
            
            double tmp=a[i][i];
            for(int k=0; k<n; k++){
                if(k==i) continue;
                double p=a[k][i]/tmp;
                for(int j=i; j<n; j++) a[k][j]=a[k][j]-p*a[i][j];
                for(int j=0; j<n; j++) b[k][j]=b[k][j]-p*b[i][j];
            } 
            
            for(int j=0; j<n; j++) a[i][j]=a[i][j]/tmp;
            for(int j=0; j<n; j++) b[i][j]=b[i][j]/tmp;
        }

        Matrix res(n, n);
        for(int i=0; i<n; i++) for(int j=0; j<n; j++){
            if(std::abs(b[i][j])<eps) res.insert(i, j, 0);
            else res.insert(i, j, b[i][j]);
        }
        return res;
    }


     T get_det(){
        const double eps=1e-10;
        assert(n==m);

        auto a=getAll();
        double res=1;
        int sgn=1;
        for(int i=0, r; i<n; i++){
            r=i;
            for(int j=i+1; j<n; j++)
                if(a[j][i]>a[r][i]) r=j;
            if(r!=i) std::swap(a[i], a[r]), sgn*=-1;
            assert(abs(a[i][i])>eps);
            
            double tmp=a[i][i];
            res*=tmp;
            for(int k=0; k<n; k++){
                if(k==i) continue;
                double p=a[k][i]/tmp;
                for(int j=i; j<n; j++) a[k][j]=a[k][j]-p*a[i][j];
            } 
            
            for(int j=0; j<n; j++) a[i][j]=a[i][j]/tmp;
        }

        return res*sgn;
    }


    Matrix<T> reshape(int row, int col){
        assert(row*col==n*m);
        Matrix<T> res(row, col);
        for(int i=0; i<n; i++){
            for(auto &[x, y]: R[i]){
                int id=i*m+x;
                int fir=id/col, sec=id%col;
                res.insert(fir, sec, y);
            }
        }

        return res;
    }

    Matrix<T> slicing(pair<int, int> row, pair<int, int> col){
        assert(row.x<n && row.y<n && col.x<m && col.y<m);
        if(row.x>row.y) std::swap(row.x, row.y);
        if(col.x>col.y) std::swap(col.x, col.y);
        Matrix<T> res(row.y-row.x+1, col.y-col.x+1);

        for(int i=row.x; i<=row.y; i++){
            for(auto &[x, y]: R[i]) if(x>=col.x && x<=col.y){
                int fir=i-row.x, sec=x-col.x;
                res.insert(fir, sec, y);
            }
        }
        return res;
    }

    //卷积
    Matrix<T> conv(const Matrix<T> &in1, const Matrix<T> &in2, std::string mode = "full"){

        Matrix<T> res(in1.n + in2.n-1, in1.m + in2.m-1);
            auto mat1 = in1.getAll();
            auto mat2 = in2.getAll();
            for(int i=0; i < in1.n+in2.n-1; i++)
                for(int j=0; j < in1.m+in2.m-1; j++)
                {
                    T temp = 0;
                    for(int m=0; m<in1.n; m++)
                        for(int n=0; n<in1.m; n++)
                            if((i-m) >= 0 && (i-m) < in2.n && (j-n) >= 0 && (j-n) < in2.m )
                                temp += mat1[m][n]*mat2[i-m][j-n];
                    res.insert(i,j,temp);

                }

        if(mode == "full")
            return res;

        
        Matrix<T> res2(in1.n, in1.m); 
            auto mat3 = res.getAll();
            
            for(int i=0; i < in1.n; i++)
                for(int j=0; j < in1.m; j++)
                {   
                    res2.insert(i,j,mat3[i+floor((in2.n)*1.0/2)][j+floor((in2.m)*1.0/2)]);
                }


        if(mode == "same")  
            return res2;
        
        Matrix<T> res3(in1.n-in2.n+1, in1.m-in2.m+1); 
            auto mat4 = res2.getAll();
            for(int i=0; i < in1.n-in2.n+1; i++)
                for(int j=0; j < in1.m-in2.m+1; j++)
                {   
                    res3.insert(i,j,mat4[i+(in2.n-1)/2][j + (in2.m-1)/2]);
                }

        
        if (mode == "vaild")
            return res3;
        
        return res;
        
    }
  
    //矩阵转换
    Matrix<T> cvToMat(cv::Mat& m1)
    {   
        Matrix<T> res(m1.size().height,m1.size().width);
        T *c =  m1.ptr<T>(0);
        for (int i = 0; i < m1.size().height; i++)
        {
            for (int j = 0; j < m1.size().width; j++)
            {
                res.insert(i,j,*(c++));
            }
            
        }
        return res;
    }

    cv::Mat matToCv(Matrix<T> mat)
    {

        cv::Mat mat1 = cv::Mat_ <T>(mat.n, mat.m);
        auto mat2 = mat.getAll();
        for (int i = 0; i < mat.n; i++)
        {
            for (int j = 0; j < mat.m; j++)
        {   
            mat1.at<T>(i,j) = mat2[i][j];
        }

        }
        return mat1;
    }

    void eigenValue(){
        assert(n == m);
        auto a = getAll();
        Eigen::MatrixXf mat(n,n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                mat(i,j) = a[i][j];
            }
        }
        Eigen::EigenSolver<Eigen::MatrixXf> es(mat);
        std::cout << "--eigenvalues--" << std::endl;
        std::cout << es.eigenvalues() << std::endl;
    }

    void eigenVector(){
        assert(n == m);
        auto a = getAll();
        Eigen::MatrixXf mat(n,n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                mat(i,j) = a[i][j];
            }
        }
        Eigen::EigenSolver<Eigen::MatrixXf> es(mat);
        std::cout << "--eigenvectors--" << std::endl;
        std::cout << es.eigenvectors()<< std::endl;
    }


};

#undef x
#undef y

#endif